name: AKS - Update Pod Containers

run-name: >
  🚢 Helm Deploy | Environment: ${{ 
    inputs.environment_name || github.event.inputs.environment_name || 'dev'
  }} | GitHub Env: ${{ inputs.environment || github.event.inputs.environment }}

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Select environment (GitHub Environment)'
        required: true
        default: 'Development'
        type: choice
        options: [Development, Production]
      environment_name:
        description: 'Optional namespace/prefix (lowercase letters & digits). Empty -> dev'
        required: false
        default: ''
      image_tag:
        description: 'Optional image tag (e.g., commit hash). Empty -> uses environment_name'
        required: false
        default: ''
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      environment_name:
        required: false
        type: string
      image_tag:
        required: false
        type: string
        description: 'Docker image tag to deploy (e.g., commit hash)'
    outputs:
      app_url:
        description: "Ingress URL (if already created by platform setup)"
        value: ${{ jobs.deploy.outputs.app_url }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || github.event.inputs.environment }}
    permissions:
      id-token: write
      contents: read

    outputs:
      app_url: ${{ steps.extract_url.outputs.app_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up variables
        run: |
          ENVIRONMENT_NAME="${{ inputs.environment_name || github.event.inputs.environment_name }}"
          if [ -n "$ENVIRONMENT_NAME" ]; then
            [[ "$ENVIRONMENT_NAME" =~ ^[a-z0-9]+$ ]] || { echo "environment_name must be ^[a-z0-9]+$"; exit 1; }
            echo "TARGET_NAMESPACE=$ENVIRONMENT_NAME" >> $GITHUB_ENV
            echo "RESOLVED_TARGET=custom($ENVIRONMENT_NAME)" >> $GITHUB_ENV
            
            # Use values.dev.yaml for 'dev' environment, values.temp.yaml for all others
            if [ "$ENVIRONMENT_NAME" = "dev" ]; then
              echo "VALUES_FILE=devops/kubernetes/charts/values.dev.yaml" >> $GITHUB_ENV
              echo "Using dev values file for dev environment"
            else
              echo "VALUES_FILE=devops/kubernetes/charts/values.temp.yaml" >> $GITHUB_ENV
              echo "Using template values file for temporary environment: $ENVIRONMENT_NAME"
            fi
          fi

          echo "K8S_DIR=devops/kubernetes/" >> $GITHUB_ENV
          echo "CHART_DIR=devops/kubernetes/charts" >> $GITHUB_ENV
          echo "ACR_NAME=teachindevacr" >> $GITHUB_ENV
          echo "ACR_LOGIN_SERVER=teachindevacr.azurecr.io" >> $GITHUB_ENV
          echo "OPENAI_KEY=${{ secrets.AZURE_OPENAI_API_KEY }}" >> $GITHUB_ENV
          echo "AZURE_SPEECH_KEY=${{ secrets.AZURE_SPEECH_KEY }}" >> $GITHUB_ENV
          echo "MANAGER_JWT_SECRET=${{ secrets.MANAGER_JWT_SECRET }}" >> $GITHUB_ENV
          echo "MANAGER_JWT_ISSUER=${{ secrets.MANAGER_JWT_ISSUER }}" >> $GITHUB_ENV
          echo "MANAGER_JWT_AUDIENCE=${{ secrets.MANAGER_JWT_AUDIENCE }}" >> $GITHUB_ENV
          echo "MANAGER_JWT_REFRESH_TOKEN_HASH_KEY=${{ secrets.MANAGER_JWT_REFRESH_TOKEN_HASH_KEY }}" >> $GITHUB_ENV

          # Shared AKS
          echo "AKS_RG=dev-zionet-learning-2025" >> $GITHUB_ENV
          echo "AKS_NAME=aks-cluster-dev" >> $GITHUB_ENV

          # PG (shared)
          echo "PG_DB=dev-pg-zionet-learning" >> $GITHUB_ENV
          echo "PG_RG=dev-zionet-learning-2025" >> $GITHUB_ENV

      - name: Get AKS credentials
        run: az aks get-credentials --resource-group $AKS_RG --name $AKS_NAME --overwrite-existing

      - name: Ensure target namespace exists
        run: |
          kubectl create namespace "$TARGET_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

      - name: Check and fix Helm release status
        run: |
          echo "Checking Helm release status for namespace: $TARGET_NAMESPACE"
          RELEASE_STATUS=$(helm status app -n "$TARGET_NAMESPACE" -o json 2>/dev/null | jq -r '.info.status' || echo "not-found")
          echo "Current release status: $RELEASE_STATUS"

          if [[ "$RELEASE_STATUS" == "pending-install" ]] || [[ "$RELEASE_STATUS" == "pending-upgrade" ]] || [[ "$RELEASE_STATUS" == "pending-rollback" ]]; then
            echo "⚠️ Found pending operation. Attempting rollback..."
            helm rollback app -n "$TARGET_NAMESPACE" || echo "Rollback failed, trying to delete release history..."
            helm delete app -n "$TARGET_NAMESPACE" --wait || echo "Delete failed, continuing anyway..."
            sleep 5
          fi

          echo "Helm release status check complete."

      - name: Wait for external IP for ingress controller
        run: |
          echo "Waiting for external IP for ingress-nginx-controller..."
          for i in {1..30}; do
            INGRESS_IP=$(kubectl -n devops-ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [[ -n "$INGRESS_IP" ]]; then
              echo "Ingress IP is ready: $INGRESS_IP"
              echo "ingress_url=http://$INGRESS_IP" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i: not ready. Sleeping 10s..."
            sleep 10
          done
          echo "Failed to get ingress IP."; exit 1

      - name: Add ingress IP to PostgreSQL firewall
        run: |
          INGRESS_IP=$(kubectl -n devops-ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          az postgres flexible-server firewall-rule create \
            --resource-group $PG_RG \
            --name $PG_DB \
            --rule-name allow-ingress-controller \
            --start-ip-address $INGRESS_IP \
            --end-ip-address $INGRESS_IP

      - name: Add AKS outbound IP to PostgreSQL firewall
        run: |
          # Try NAT Gateway first, else fallback to Load Balancer
          OUTBOUND_IP_ID=$(az aks show \
            --resource-group $AKS_RG \
            --name $AKS_NAME \
            --query "networkProfile.natGatewayProfile.effectiveOutboundIPs[0].id" -o tsv 2>/dev/null || true)

          if [ -z "$OUTBOUND_IP_ID" ] || [ "$OUTBOUND_IP_ID" = "null" ]; then
            echo "No NAT Gateway found, checking Load Balancer outbound IP..."
            OUTBOUND_IP_ID=$(az aks show \
              --resource-group $AKS_RG \
              --name $AKS_NAME \
              --query "networkProfile.loadBalancerProfile.effectiveOutboundIPs[0].id" -o tsv)
          fi

          if [ -z "$OUTBOUND_IP_ID" ] || [ "$OUTBOUND_IP_ID" = "null" ]; then
            echo "❌ Could not detect outbound IP ID for AKS cluster."
            exit 1
          fi

          AKS_EGRESS_IP=$(az resource show --ids $OUTBOUND_IP_ID --query "properties.ipAddress" -o tsv)

          echo "AKS outbound IP: $AKS_EGRESS_IP"

          az postgres flexible-server firewall-rule create \
            --resource-group $PG_RG \
            --name $PG_DB \
            --rule-name allow-aks-egress \
            --start-ip-address $AKS_EGRESS_IP \
            --end-ip-address $AKS_EGRESS_IP

      - name: Get Static Web App URL
        run: |
          # First check if frontend is enabled in the values file
          echo "Checking if frontend is enabled in values file: $VALUES_FILE"
          FRONTEND_ENABLED_IN_VALUES=$(grep -A 5 "^frontend:" "$VALUES_FILE" | grep "enabled:" | awk '{print $2}' || echo "false")
          echo "Frontend enabled in values: $FRONTEND_ENABLED_IN_VALUES"
          
          if [ "$FRONTEND_ENABLED_IN_VALUES" != "true" ]; then
            echo "Frontend is disabled in values file - skipping Static Web App lookup"
            echo "STATIC_WEB_APP_HOSTNAME=" >> $GITHUB_ENV
            exit 0
          fi
          
          # Frontend is enabled in values, so check if Static Web App exists
          echo "Frontend enabled in values, checking for Static Web App..."
          FRONTEND_RG="${TARGET_NAMESPACE}-zionet-learning-2025"
          echo "Frontend resource group: $FRONTEND_RG"
          
          # Get Static Web App hostname for frontend proxy
          STATIC_WEB_APP_NAME="static-web-app-${TARGET_NAMESPACE}"
          echo "Looking for Static Web App: $STATIC_WEB_APP_NAME in resource group: $FRONTEND_RG"
          
          STATIC_WEB_APP_URL=$(az staticwebapp show \
            --name "$STATIC_WEB_APP_NAME" \
            --resource-group "$FRONTEND_RG" \
            --query "defaultHostname" -o tsv 2>/dev/null || echo "")
          
          if [ -z "$STATIC_WEB_APP_URL" ]; then
            echo "Static Web App not found: $STATIC_WEB_APP_NAME in $FRONTEND_RG"
            echo "Frontend enabled in values but no Static Web App found"
            echo "STATIC_WEB_APP_HOSTNAME=" >> $GITHUB_ENV
          else
            echo "Found Static Web App: $STATIC_WEB_APP_URL"
            echo "STATIC_WEB_APP_HOSTNAME=$STATIC_WEB_APP_URL" >> $GITHUB_ENV
          fi

      - name: Helm template sanity (no Namespace objects)
        run: |
          # Use image_tag if provided, otherwise fall back to TARGET_NAMESPACE
          IMAGE_TAG="${{ inputs.image_tag || github.event.inputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="$TARGET_NAMESPACE"
          fi
          
          # Build helm command with conditional frontend hostname
          HELM_ARGS=(
            "app" "$CHART_DIR" "-f" "$VALUES_FILE"
            "--set" "namespace.name=$TARGET_NAMESPACE"
            "--set" "namespace.create=false"
            "--set" "global.namePrefix=$TARGET_NAMESPACE"
            "--set" "global.dockerRegistry=$ACR_LOGIN_SERVER"
            "--set" "global.environment=$IMAGE_TAG"
            "--set-string" "engine.env.AzureOpenAI__ApiKey=$OPENAI_KEY"
            "--set-string" "engine.env.AzureSpeech__SubscriptionKey=$AZURE_SPEECH_KEY"
            "--set-string" "manager.env.Jwt__Secret=$MANAGER_JWT_SECRET"
            "--set-string" "manager.env.Jwt__Issuer=$MANAGER_JWT_ISSUER"
            "--set-string" "manager.env.Jwt__Audience=$MANAGER_JWT_AUDIENCE"
            "--set-string" "manager.env.Jwt__RefreshTokenHashKey=$MANAGER_JWT_REFRESH_TOKEN_HASH_KEY"
            "--set" "dapr.installComponents=false"
          )
          
          # Only set hostname if frontend is enabled and hostname is not empty
          if [ "$FRONTEND_ENABLED" = "true" ] && [ -n "$STATIC_WEB_APP_HOSTNAME" ]; then
            HELM_ARGS+=("--set" "frontend.staticWebApp.hostname=$STATIC_WEB_APP_HOSTNAME")
          fi
          
          helm template "${HELM_ARGS[@]}" \
          | grep -n '^kind: Namespace' && { echo "Namespace still rendered"; exit 1; } || echo "OK: no Namespace in chart"

      - name: Helm upgrade/install app
        run: |
          # Use image_tag if provided, otherwise fall back to TARGET_NAMESPACE
          IMAGE_TAG="${{ inputs.image_tag || github.event.inputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="$TARGET_NAMESPACE"
          fi
          
          # Build helm command with conditional frontend hostname
          HELM_ARGS=(
            "--namespace" "$TARGET_NAMESPACE"
            "-f" "$VALUES_FILE"
            "--set" "namespace.name=$TARGET_NAMESPACE"
            "--set" "namespace.create=false"
            "--set" "global.namePrefix=$TARGET_NAMESPACE"
            "--set" "global.dockerRegistry=$ACR_LOGIN_SERVER"
            "--set" "global.environment=$IMAGE_TAG"
            "--set-string" "engine.env.AzureOpenAI__ApiKey=$OPENAI_KEY"
            "--set-string" "engine.env.AzureSpeech__SubscriptionKey=$AZURE_SPEECH_KEY"
            "--set-string" "manager.env.Jwt__Secret=$MANAGER_JWT_SECRET"
            "--set-string" "manager.env.Jwt__Issuer=$MANAGER_JWT_ISSUER"
            "--set-string" "manager.env.Jwt__Audience=$MANAGER_JWT_AUDIENCE"
            "--set-string" "manager.env.Jwt__RefreshTokenHashKey=$MANAGER_JWT_REFRESH_TOKEN_HASH_KEY"
            "--set" "dapr.installComponents=false"
          )
          
          # Only set hostname if hostname is not empty (frontend enabled in values + Static Web App exists)
          if [ -n "$STATIC_WEB_APP_HOSTNAME" ]; then
            HELM_ARGS+=("--set" "frontend.staticWebApp.hostname=$STATIC_WEB_APP_HOSTNAME")
          fi
          
          helm upgrade --install app "$CHART_DIR" "${HELM_ARGS[@]}"

      - name: Diagnostics (on failure)
        if: failure()
        run: |
          ns="$TARGET_NAMESPACE"
          kubectl -n "$ns" get all
          kubectl -n "$ns" get events --sort-by=.lastTimestamp | tail -n 200 || true
          for p in $(kubectl -n "$ns" get pods -o name); do
            echo "## $p"
            kubectl -n "$ns" describe "$p" || true
            kubectl -n "$ns" logs "$p" --all-containers --tail=200 || true
          done
