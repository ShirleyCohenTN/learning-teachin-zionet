name: AKS - Deploy Services to AKS

on:
  workflow_dispatch:
   inputs:
     environment:
        description: 'Enter environment name'
        required: true
        default: 'Development'
        type: string
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    outputs:
      app_url:
        description: "Full URL of the deployed load balancer service"
        value: ${{ jobs.deploy.outputs.app_url }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: 'Development'
    permissions:
      id-token: write
      contents: read

    outputs:
      app_url: ${{ steps.extract_url.outputs.app_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up variables
        run: |
          INPUT_ENV="${{ inputs.environment || github.event.inputs.environment }}"
          case "$INPUT_ENV" in
            "Development")
              ENVIRONMENT_NAME="dev"
              ;;
            "Production")
              ENVIRONMENT_NAME="prod"
              ;;
            *)
              # Support custom environments (feature branches, testing, etc.)
              ENVIRONMENT_NAME="$INPUT_ENV"
              ;;
          esac
          
          echo "ENVIRONMENT_NAME=$ENVIRONMENT_NAME" >> $GITHUB_ENV
          echo "K8S_DIR=devops/kubernetes/" >> $GITHUB_ENV
          echo "DOCKER_REGISTRY=${{ secrets.DOCKER_USERNAME }}" >> $GITHUB_ENV
          echo "OPENAI_KEY=${{ secrets.AZURE_OPENAI_API_KEY }}" >> $GITHUB_ENV
          echo "PG_DB=${ENVIRONMENT_NAME}-pg-zionet-learning" >> $GITHUB_ENV
          echo "PG_RG=${ENVIRONMENT_NAME}-zionet-learning-2025" >> $GITHUB_ENV

          
          # Now we use only dev as the shared AKS cluster
          echo "AKS_RG=dev-zionet-learning-2025" >> $GITHUB_ENV
          echo "MC_AKS_RG=MC_dev-zionet-learning-2025_aks-cluster-dev_westeurope" >> $GITHUB_ENV
          echo "AKS_NAME=aks-cluster-dev" >> $GITHUB_ENV

          

      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group $AKS_RG --name $AKS_NAME --overwrite-existing

      - name: Install/Upgrade Dapr control plane
        run: |
          cd devops/helm-tools
          chmod +x dapr-control-plane.sh
          ./dapr-control-plane.sh

      - name: Create namespace dynamically
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: ${{env.ENVIRONMENT_NAME}}
            labels:
              name: ${{env.ENVIRONMENT_NAME}}
              environment: ${{env.ENVIRONMENT_NAME}}
              managed-by: github-actions
              created-by: aks-kubectl-apply-workflow
          EOF

      - name: Apply Dapr components
        run: kubectl apply -f "$K8S_DIR/dapr/components" --recursive

      - name: Apply services
        run: |
          find "$K8S_DIR/services" -type f -name '*.yaml' | while read file; do
            echo "Applying $file"
            ENVIRONMENT_NAME=$ENVIRONMENT_NAME 
            envsubst < "$file" | kubectl apply -f -
          done
  
      - name: Apply deployments (with registry and OpenAI key substitution)
        run: |
          export OPENAI_KEY="$OPENAI_KEY"
          find "$K8S_DIR/deployments" -type f -name '*.yaml' | while read file; do
            echo "Applying $file"
            ENVIRONMENT_NAME=$ENVIRONMENT_NAME DOCKER_REGISTRY=$DOCKER_REGISTRY OPENAI_KEY=$OPENAI_KEY envsubst < "$file" | kubectl apply -f -
          done

      - name: setup-ingress-controller
        run: |
          cd devops/helm-tools
          chmod +x setup-ingress-controller.sh
          ./setup-ingress-controller.sh

      - name: Add grafana
        run: |
          cd devops/helm-tools
          chmod +x grafana.sh
          ./grafana.sh

      - name: Apply ingresses
        run: |
          find "$K8S_DIR/ingress" -type f -name '*.yaml' | while read file; do
              echo "Applying ingress: $file"
              ENVIRONMENT_NAME=$ENVIRONMENT_NAME \
              envsubst < "$file" | kubectl apply -f -
            done

      - name: Add prometheus
        run: |
          cd devops/helm-tools/prometheus
          chmod +x prometheus.sh
          ./prometheus.sh

      - name: Add Loki (logs stack)
        run: |
          cd devops/helm-tools/loki
          chmod +x loki.sh
          ./loki.sh
    
      - name: Setup HTTPS certificates
        run: |
          cd devops/helm-tools
          chmod +x setup-https.sh
          ./setup-https.sh   
    
      - name: Wait for external IP for ingress controller
        id: wait_for_ingress_ip
        run: |
          echo "Waiting for external IP for ingress-nginx-controller..."
          for i in {1..30}; do
            INGRESS_IP=$(kubectl -n devops-ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [[ -n "$INGRESS_IP" ]]; then
              echo "Ingress IP is ready: $INGRESS_IP"
              echo "ingress_url=http://$INGRESS_IP" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i: Ingress IP not yet assigned. Waiting 10s..."
            sleep 10
          done
          echo "Failed to get ingress IP after waiting. Check 'kubectl get svc ingress-nginx-controller -n devops-ingress-nginx'"
          exit 1
      

      - name: Add ingress IP to PostgreSQL firewall
        run: |
          INGRESS_IP=$(kubectl -n devops-ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          az postgres flexible-server firewall-rule create \
            --resource-group $PG_RG \
            --name $PG_DB \
            --rule-name allow-ingress-controller \
            --start-ip-address $INGRESS_IP \
            --end-ip-address $INGRESS_IP
            
    
      - name: Restart all pods in the namespace
        run: |
          kubectl delete pod --all -n $ENVIRONMENT_NAME


      - name: Output external URL
        id: extract_url
        run: |
          echo "app_url=${{ steps.wait_for_ingress_ip.outputs.ingress_url }}" >> $GITHUB_OUTPUT
          echo "App URL: ${{ steps.wait_for_ingress_ip.outputs.ingress_url }}"