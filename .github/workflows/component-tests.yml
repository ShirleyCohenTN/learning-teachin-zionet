name: Component Tests

on:
  workflow_dispatch:
    inputs:
      services:
        description: "Comma-separated services to test (e.g., Engine,NewService)"
        required: true
        default: "Engine"
      testFilter:
        description: "Optional dotnet test --filter e.g., FullyQualifiedName~EngineComponentTests.ChatAiServiceTests)"
        required: false
        default: ""

# Cancel prior runs for the same ref (branch/tag)
concurrency:
  group: component-tests-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      services_json: ${{ steps.parse.outputs.services_json }}
      test_filter: ${{ steps.parse.outputs.test_filter }}
    steps:
      - name: Parse inputs
        id: parse
        shell: bash
        run: |
            set -euo pipefail
            SVC_IN="${{ github.event.inputs.services }}"
            TFILT="${{ github.event.inputs.testFilter }}"
        
            [ -n "${SVC_IN}" ] || SVC_IN="Engine"
        
            # Normalize -> JSON array
            SVC_IN="$(echo "${SVC_IN}" | tr -d ' ')"
            IFS=',' read -ra ARR <<< "${SVC_IN}"
            JSON="["
            SEP=""
            for s in "${ARR[@]}"; do
              [ -n "$s" ] || continue
              JSON="${JSON}${SEP}\"${s}\""
              SEP=","
            done
            JSON="${JSON}]"
        
            echo "services (raw): ${SVC_IN}"
            echo "matrix JSON   : ${JSON}"
            echo "testFilter    : ${TFILT}"
        
            echo "services_json=${JSON}" >> "$GITHUB_OUTPUT"
            echo "test_filter=${TFILT}" >> "$GITHUB_OUTPUT"

  test-component:
    needs: prepare
    runs-on: ubuntu-latest
    timeout-minutes: 30
    defaults:
      run:
        working-directory: backend/ContainerApp

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services_json) }}

    # NOTE: If a NEW service's component tests require extra env vars,
    # add them here in 'env:' (global for the job) or on specific steps.
    # Example (when NewService is added):
    #   FOO__ApiKey: ${{ secrets.FOO_API_KEY }}
    # For service-specific env, you can use a case block in steps to export vars before 'dotnet test'.
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      DOTNET_NOLOGO: 1
      AzureOpenAI__Endpoint: "https://france-teachin-open-ai.openai.azure.com/"
      AzureOpenAI__ApiKey: ${{ secrets.AZURE_OPENAI_API_KEY }}
      AzureOpenAI__DeploymentName: "gpt-4.1-mini"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Compute paths for ${{ matrix.service }}
        id: paths
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Compute paths (inputs & CWD)"
          echo "CWD: $(pwd)"
          echo "Service: ${{ matrix.service }}"
          echo "Working directory content (top):"
          ls -la
          echo "::endgroup::"

          SVC="${{ matrix.service }}"

          # === Convention mapping ===
          # Service project:             <Service>/<Service>.csproj
          # Component tests project:     <Service>ComponentTests/<Service>ComponentTests.csproj
          # If a service deviates, add a case here.
          case "${SVC}" in
            # Example custom mapping (keep commented until needed)
            # CustomService)
            #   SERVICE_CSProj="CustomService/src/Service.csproj"
            #   TEST_CSProj="CustomServiceTests/ServiceTests.csproj"
            #   ;;
            *)
              SERVICE_CSProj="${SVC}/${SVC}.csproj"
              TEST_CSProj="${SVC}ComponentTests/${SVC}ComponentTests.csproj"
              ;;
          esac

          echo "::group::Computed csproj paths"
          echo "SERVICE_CSProj=${SERVICE_CSProj}"
          echo "TEST_CSProj=${TEST_CSProj}"
          echo "::endgroup::"

          echo "::group::Existence check"
          if [ -f "${SERVICE_CSProj}" ]; then echo "OK: ${SERVICE_CSProj} exists"; else echo "MISSING: ${SERVICE_CSProj}"; fi
          if [ -f "${TEST_CSProj}" ]; then echo "OK: ${TEST_CSProj} exists"; else echo "MISSING: ${TEST_CSProj}"; fi
          echo "::endgroup::"

          # Fail fast with clear message if missing
          [ -f "${SERVICE_CSProj}" ] || { echo "Service project not found: ${SERVICE_CSProj}"; exit 1; }
          [ -f "${TEST_CSProj}" ]   || { echo "Test project not found: ${TEST_CSProj}"; exit 1; }

          # Expose outputs for later steps
          echo "service_csproj=${SERVICE_CSProj}" >> "$GITHUB_OUTPUT"
          echo "test_csproj=${TEST_CSProj}"       >> "$GITHUB_OUTPUT"

      - name: Restore ${{ matrix.service }}
        run: |
          echo "Restoring: ${{ steps.paths.outputs.service_csproj }}"
          dotnet restore "${{ steps.paths.outputs.service_csproj }}"

      - name: Restore ${{ matrix.service }} Component Tests
        run: |
          echo "Restoring tests: ${{ steps.paths.outputs.test_csproj }}"
          dotnet restore "${{ steps.paths.outputs.test_csproj }}"

      - name: Build (service + tests) - ${{ matrix.service }}
        run: |
          echo "Building service: ${{ steps.paths.outputs.service_csproj }}"
          dotnet build "${{ steps.paths.outputs.service_csproj }}" --no-restore -c Release
          echo "Building tests:   ${{ steps.paths.outputs.test_csproj }}"
          dotnet build "${{ steps.paths.outputs.test_csproj }}" --no-restore -c Release

      - name: Run tests (${{ matrix.service }})
        shell: bash
        run: |
          set -euo pipefail
          TFILT='${{ needs.prepare.outputs.test_filter }}'
          if [ -z "${TFILT}" ]; then
            # Default: run all tests for the service's test root namespace
            TFILT="FullyQualifiedName~${{ matrix.service }}ComponentTests"
          fi

          echo "Test project: ${{ steps.paths.outputs.test_csproj }}"
          echo "Filter: ${TFILT}"
          dotnet test "${{ steps.paths.outputs.test_csproj }}" \
            --no-build -c Release \
            --filter "${TFILT}" \
            --logger "trx;LogFileName=${{ matrix.service }}.trx" \
            --logger "console;verbosity=detailed" \

      - name: Upload test results (${{ matrix.service }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: TestResults-${{ matrix.service }}
          path: backend/ContainerApp/**/${{ matrix.service }}.trx
          if-no-files-found: warn

# === How to add another service later ===
# 1) Keep the same folder convention or add a case in the "Compute paths" step.
# 2) If the new service needs special env vars, add them under the job-level 'env:' (or on specific steps).
# 3) At run time, set the input 'services' to include it (e.g., Engine,NewService).
#    No workflow changes needed if convention is kept.
