name: Component Tests

on:
  workflow_call:
    inputs:
      service:
        description: "Single service to test (e.g., Engine)"
        type: string
        required: true
      testFilter:
        description: "Optional dotnet test --filter"
        type: string
        required: false
        default: ""
    secrets:
      AZURE_OPENAI_API_KEY:
        required: true
        
  workflow_dispatch:
    inputs:
      service:
        description: "Single service to test (e.g., Engine)"
        required: true
        default: "Engine"
      testFilter:
        description: "Optional dotnet test --filter"
        required: false
        default: ""

# Cancel prior runs of SAME service on same ref only
concurrency:
  group: component-tests-${{ github.ref }}-${{ inputs.service || github.event.inputs.service }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  test-component:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    defaults:
      run:
        working-directory: backend/ContainerApp
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      DOTNET_NOLOGO: 1
      AzureOpenAI__Endpoint: "https://france-teachin-open-ai.openai.azure.com/"
      AzureOpenAI__ApiKey: ${{ secrets.AZURE_OPENAI_API_KEY }}
      AzureOpenAI__DeploymentName: "gpt-4.1-mini"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Compute paths for ${{ inputs.service }}
        id: paths
        shell: bash
        run: |
          set -euo pipefail
          SVC="${{ inputs.service }}"
          echo "::group::Compute paths (CWD + service)"
          echo "CWD: $(pwd)"
          echo "Service: ${SVC}"
          echo "::endgroup::"

          case "${SVC}" in
            # Custom mapping examples (uncomment & adjust when needed)
            # CustomService)
            #   SERVICE_CSProj="CustomService/src/Service.csproj"
            #   TEST_CSProj="CustomServiceTests/ServiceTests.csproj"
            #   ;;
            *)
              SERVICE_CSProj="${SVC}/${SVC}.csproj"
              TEST_CSProj="${SVC}ComponentTests/${SVC}ComponentTests.csproj"
              ;;
          esac

          echo "::group::Computed csproj paths"
          echo "SERVICE_CSProj=${SERVICE_CSProj}"
          echo "TEST_CSProj=${TEST_CSProj}"
          echo "::endgroup::"

          echo "::group::Existence check"
          if [ -f "${SERVICE_CSProj}" ]; then echo "OK: ${SERVICE_CSProj} exists"; else echo "MISSING: ${SERVICE_CSProj}"; fi
          if [ -f "${TEST_CSProj}" ]; then echo "OK: ${TEST_CSProj} exists"; else echo "MISSING: ${TEST_CSProj}"; fi
          echo "::endgroup::"

          [ -f "${SERVICE_CSProj}" ] || { echo "Service project not found: ${SERVICE_CSProj}"; exit 1; }
          [ -f "${TEST_CSProj}" ]   || { echo "Test project not found: ${TEST_CSProj}"; exit 1; }

          echo "service_csproj=${SERVICE_CSProj}" >> "$GITHUB_OUTPUT"
          echo "test_csproj=${TEST_CSProj}"       >> "$GITHUB_OUTPUT"

      - name: Restore ${{ inputs.service }}
        run: |
          echo "Restoring: ${{ steps.paths.outputs.service_csproj }}"
          dotnet restore "${{ steps.paths.outputs.service_csproj }}"

      - name: Restore ${{ inputs.service }} Component Tests
        run: |
          echo "Restoring tests: ${{ steps.paths.outputs.test_csproj }}"
          dotnet restore "${{ steps.paths.outputs.test_csproj }}"

      - name: Build (service + tests) - ${{ inputs.service }}
        run: |
          echo "Building service: ${{ steps.paths.outputs.service_csproj }}"
          dotnet build "${{ steps.paths.outputs.service_csproj }}" --no-restore -c Release
          echo "Building tests:   ${{ steps.paths.outputs.test_csproj }}"
          dotnet build "${{ steps.paths.outputs.test_csproj }}" --no-restore -c Release

      - name: Run tests (${{ inputs.service }})
        shell: bash
        run: |
          set -euo pipefail
          TFILT='${{ inputs.testFilter }}'
          if [ -z "${TFILT}" ]; then
            TFILT="FullyQualifiedName~${{ inputs.service }}ComponentTests"
          fi
          echo "Test project: ${{ steps.paths.outputs.test_csproj }}"
          echo "Filter: ${TFILT}"
          dotnet test "${{ steps.paths.outputs.test_csproj }}" \
            --no-build -c Release \
            --filter "${TFILT}" \
            --logger "trx;LogFileName=${{ inputs.service }}.trx" \
            --logger "console;verbosity=detailed"

      - name: Upload test results (${{ inputs.service }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
            name: TestResults-${{ inputs.service }}
            path: backend/ContainerApp/**/${{ inputs.service }}.trx
            if-no-files-found: warn

# === How to add another service later ===
# 1) Keep folder convention or add a case in "Compute paths".
# 2) Add needed env vars at job-level if required.
# 3) Calling workflow supplies one service per matrix job.
